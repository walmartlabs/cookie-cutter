<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>gRPC · Cookie Cutter</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Though Cookie Cutter is a framework for message streaming APIs, it has support for writing gRPC services and invoking other gRPC services from sinks or message handlers. Currently the only limitation is that client-side streams are not supported when implementing gRPC servers, however server-side streams are. The gRPC solution is intertwined with the Proto module and currently only supports protobuf encoders generated with `protobufjs`."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="gRPC · Cookie Cutter"/><meta property="og:type" content="website"/><meta property="og:url" content="https://walmartlabs.github.io/cookie-cutter/"/><meta property="og:description" content="Though Cookie Cutter is a framework for message streaming APIs, it has support for writing gRPC services and invoking other gRPC services from sinks or message handlers. Currently the only limitation is that client-side streams are not supported when implementing gRPC servers, however server-side streams are. The gRPC solution is intertwined with the Proto module and currently only supports protobuf encoders generated with `protobufjs`."/><meta property="og:image" content="https://walmartlabs.github.io/cookie-cutter/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://walmartlabs.github.io/cookie-cutter/img/docusaurus.png"/><link rel="shortcut icon" href="/cookie-cutter/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/cookie-cutter/js/scrollSpy.js"></script><link rel="stylesheet" href="/cookie-cutter/css/main.css"/><script src="/cookie-cutter/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/cookie-cutter/"><img class="logo" src="/cookie-cutter/img/cookie.svg" alt="Cookie Cutter"/><h2 class="headerTitleWithLogo">Cookie Cutter</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/cookie-cutter/docs/intro-getting-started" target="_self">Introduction</a></li><li class="siteNavGroupActive"><a href="/cookie-cutter/docs/intro-inputs" target="_self">API</a></li><li class=""><a href="/cookie-cutter/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Modules</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-inputs">Inputs</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-message-handling">Message Handling</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-outputs">Outputs</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/versioning-contribution">Versioning and Contribution Guide</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Components</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-dispatch-context">Dispatch Context</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-state">State</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-metrics">Metrics</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-tracing">Tracing</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-validation">Validation</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-encoding">Encoding</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-config">Config</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-testing">Testing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Modules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-kafka">Kafka</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-azure">Azure</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/cookie-cutter/docs/module-grpc">gRPC</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-validatejs">ValidateJS</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-mssql">MSSQL</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-timer">Timer</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-statsd">StatsD</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-protobuf">Protobuf</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-prometheus">Prometheus</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-redis">Redis</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-s3">S3</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">gRPC</h1></header><article><div><span><p>Though Cookie Cutter is a framework for message streaming APIs, it has support for writing gRPC services and invoking other gRPC services from sinks or message handlers. Currently the only limitation is that client-side streams are not supported when implementing gRPC servers, however server-side streams are. The gRPC solution is intertwined with the Proto module and currently only supports protobuf encoders generated with <code>protobufjs</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="defining-service-definitions"></a><a href="#defining-service-definitions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Service Definitions</h2>
<p>For the gRPC service to accept requests for our operations and use the encoders generated with <code>protobufjs</code> we need to create a service definition.</p>
<pre><code class="hljs css language-protobuf"><span class="hljs-keyword">package</span> sample;

<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SampleRequest</span> </span>{
    <span class="hljs-built_in">int32</span> id = <span class="hljs-number">1</span>;
}

<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SampleResponse</span> </span>{
    <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;
}

<span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">SampleService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SampleOperation(SampleRequest) (SampleResponse)</span>;
    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SampleStream(SampleRequest) stream(SampleRequest)</span>;
}
</code></pre>
<p>Service definitions follow a simple pattern, for each operation they define the type of the encoder class for request and response. In addition you may want to define an interface for gRPC clients.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">interface</span> ISampleService {
    SampleOperation(req: SampleRequest, context: SpanContext): <span class="hljs-built_in">Promise</span>&lt;SampleResponse&gt;;
    SampleStream(req: SampleRequest, context: SpanContext): AsyncIterableIterator&lt;SampleResponse&gt;;
}
</code></pre>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> proto <span class="hljs-keyword">from</span> <span class="hljs-string">"bundle"</span>; <span class="hljs-comment">// these are the pbjs generates types</span>

<span class="hljs-keyword">const</span> SampleServiceDefinition = {
    SampleOperation: {
        path: <span class="hljs-string">"/sample.SampleService/SampleOperation"</span>,
        requestType: proto.SampleRequest,
        requestStream: <span class="hljs-literal">false</span>,
        responseType: proto.SampleResponse,
        responseStream: <span class="hljs-literal">false</span>,
    },
    SampleStream: {
        path: <span class="hljs-string">"/sample.SampleService/SampleStream"</span>,
        requestType: proto.SampleRequest,
        requestStream: <span class="hljs-literal">false</span>,
        responseType: proto.SampleResponse,
        responseStream: <span class="hljs-literal">true</span>,
    },
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="grpc-server"></a><a href="#grpc-server" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>gRPC Server</h2>
<h3><a class="anchor" aria-hidden="true" id="rpc"></a><a href="#rpc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC</h3>
<p>A simple gRPC server for above's service definition looks like below. Cookie Cutter will treat every incoming gRPC request as a message that flows through the framework's pipeline. The main difference is that the message handler's function must be named after the gRPC operation and not after the request's message type. Also the message handler will have a return value now that represents the gRPC response. A message handler may in addition publish or store additional messages. The gRPC request will be completed by sending the response after all publish and store outputs have been processed - this includes any potential retries due to optimistic concurrency issues.</p>
<pre><code class="hljs css language-typescript">Application.create()
    .input()
        .add(grpcSource({
            host: <span class="hljs-string">"localhost"</span>,
            port: <span class="hljs-number">5000</span>,
            definitions: [ SampleServiceDefinition ]
        }))
        .done()
    .dispatch({
        onSampleOperation: (req: ISampleRequest, ctx: IDispatchContext): <span class="hljs-function"><span class="hljs-params">ISampleResponse</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> { name: req.id.toString() };
        },
    });
    .run(ErrorHandlingMode.LogAndContinue, ParallelismMode.Rpc);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="server-side-streams"></a><a href="#server-side-streams" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Server-Side Streams</h3>
<p>The example below accepts gRPC client requests and replies with a stream of 10 messages (once per second) and then ends the stream call.</p>
<pre><code class="hljs css language-typescript">Application.create()
    .input()
        .add(grpcSource({
            host: <span class="hljs-string">"localhost"</span>,
            port: <span class="hljs-number">5000</span>,
            definitions: [ SampleServiceDefinition ]
        }))
        .add(intervalSource({
            timeout: <span class="hljs-number">1000</span>,
        }))
        .done()
    .dispatch({
        consumers: [ ],
        onSampleStream: (req: ISampleRequest, ctx: IDispatchContext): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
            <span class="hljs-keyword">const</span> stream = ctx.metadata&lt;IResponseStream&lt;ISampleResponse&gt;&gt;(GrpcMetadata.ResponseStream);
            <span class="hljs-keyword">this</span>.consumers.push({ stream, count: <span class="hljs-number">0</span> });
        },
        onInterval: (msg: IInterval, ctx: IDispatchContext): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item of <span class="hljs-keyword">this</span>.consumers) {
                <span class="hljs-keyword">const</span> { stream } = item;
                <span class="hljs-keyword">if</span> (item.count === <span class="hljs-number">10</span>) {
                    stream.close();
                } <span class="hljs-keyword">else</span> {
                    ctx.logger.info(<span class="hljs-string">`sending msg to <span class="hljs-subst">${item.peer}</span>`</span>);
                    <span class="hljs-keyword">await</span> item.send({ name: <span class="hljs-string">"hello "</span> + item.count });
                }
                item.count++;
            }
        }
    });
    .run(ErrorHandlingMode.LogAndContinue, ParallelismMode.Rpc);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="metadata"></a><a href="#metadata" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Metadata</h3>
<p>The following metadata is available for gRPC requests</p>
<table>
<thead>
<tr><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>GrpcMetadata.Peer</td><td>the host and port of the client sending the request</td></tr>
<tr><td>GrpcMetadata.OperationPath</td><td>the full name of the operation invoked by the client</td></tr>
<tr><td>GrpcMetadata.ResponseStream</td><td>handle to a <code>IResponseStream&lt;TResponse&gt;</code> object that can be used for server-side streams</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="error-handling"></a><a href="#error-handling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error Handling</h3>
<p>Any errors thrown by a message handler will be relayed to the gRPC client. This only works in <code>LogAndContinue</code> mode though, if the service has to run in <code>LogAndRetry</code> mode then it is possible to return an error from a message handler instead of throwing it, which will then propagate to the gRPC client the same way.</p>
<pre><code class="hljs css language-typescript">Application.create()
    .input()
        .add(grpcSource(...))
        .done()
    .dispatch({
        onSampleOperation: (req: ISampleRequest, ctx: IDispatchContext): <span class="hljs-function"><span class="hljs-params">ISampleResponse</span> =&gt;</span> {
            <span class="hljs-comment">// the preferred way to error out a call</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"bad input"</span>);
        },
    });
    .run(ErrorHandlingMode.LogAndContinue, ParallelismMode.Rpc);

Application.create()
    .input()
        .add(grpcSource(...))
        .done()
    .dispatch({
        onSampleOperation: (req: ISampleRequest, ctx: IDispatchContext): ISampleResponse | <span class="hljs-function"><span class="hljs-params">Error</span> =&gt;</span> {
            <span class="hljs-comment">// use this pattern if service is LogAndRetry</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"bad input"</span>);
        },
    });
    .run(ErrorHandlingMode.LogAndRetry, ParallelismMode.Rpc);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="runtime-options"></a><a href="#runtime-options" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Runtime Options</h3>
<p>It is recommended to run gRPC servers in <code>LogAndContinue</code> + <code>RPC</code> mode as incoming requests usually don't require any kinds of ordering guarantees are can be executed independent of each other.</p>
<h2><a class="anchor" aria-hidden="true" id="grpc-client"></a><a href="#grpc-client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>gRPC Client</h2>
<p>gRPC clients can be created with the <code>grpcClient</code> helper function and should be registered as services with Cookie Cutter as they require initialization and disposal.</p>
<pre><code class="hljs css language-typescript">Application.create()
    .services()
        .add(<span class="hljs-string">"some-service"</span>, grpcClient&lt;ISampleService&gt;({
            endpoint: <span class="hljs-string">"localhost:5000"</span>,
            definition: SampleServiceDefinition,
        }))
        done()
    .dispatch({
        onSomeInput: (msg: ISomeInput, ctx: IDispatchContext): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
            <span class="hljs-keyword">const</span> client = ctx.services.get&lt;ISampleService&gt;(<span class="hljs-string">"some-service"</span>);

            <span class="hljs-comment">// invoke regular RPC call</span>
            <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> client.SampleOperation({ id: <span class="hljs-number">1</span> }, ctx.trace.context);

            <span class="hljs-comment">// consume stream</span>
            <span class="hljs-keyword">const</span> stream = client.SampleStream({ id: <span class="hljs-number">1</span> <span class="hljs-number">1</span>}, ctx.trace.context);
            <span class="hljs-keyword">for</span> <span class="hljs-keyword">async</span> (<span class="hljs-keyword">const</span> item of stream) {
                <span class="hljs-comment">// do something</span>
            }
        }
    })
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/cookie-cutter/docs/module-azure"><span class="arrow-prev">← </span><span>Azure</span></a><a class="docs-next button" href="/cookie-cutter/docs/module-validatejs"><span class="function-name-prevnext">ValidateJS</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#defining-service-definitions">Defining Service Definitions</a></li><li><a href="#grpc-server">gRPC Server</a><ul class="toc-headings"><li><a href="#rpc">RPC</a></li><li><a href="#server-side-streams">Server-Side Streams</a></li><li><a href="#metadata">Metadata</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#runtime-options">Runtime Options</a></li></ul></li><li><a href="#grpc-client">gRPC Client</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/cookie-cutter/" class="nav-home"><img src="/cookie-cutter/img/cookie.svg" alt="Cookie Cutter" width="66" height="58"/></a><div><h5>Docs</h5><a href="/cookie-cutter/docs/intro-getting-started.html">Introduction</a><a href="/cookie-cutter/docs/module-kafka.html">Kafka</a></div><div><h5>More</h5><a href="/cookie-cutter/blog">Blog</a></div></section><section class="copyright">Copyright © 2020 Walmart Inc.</section></footer></div></body></html>