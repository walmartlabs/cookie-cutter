<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Azure · Cookie Cutter</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Cookie Cutter&#x27;s Azure module is split into three major pieces:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Azure · Cookie Cutter"/><meta property="og:type" content="website"/><meta property="og:url" content="https://walmartlabs.github.io/cookie-cutter/"/><meta property="og:description" content="Cookie Cutter&#x27;s Azure module is split into three major pieces:"/><meta property="og:image" content="https://walmartlabs.github.io/cookie-cutter/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://walmartlabs.github.io/cookie-cutter/img/docusaurus.png"/><link rel="shortcut icon" href="/cookie-cutter/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/cookie-cutter/js/scrollSpy.js"></script><link rel="stylesheet" href="/cookie-cutter/css/main.css"/><script src="/cookie-cutter/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/cookie-cutter/"><img class="logo" src="/cookie-cutter/img/cookie.svg" alt="Cookie Cutter"/><h2 class="headerTitleWithLogo">Cookie Cutter</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/cookie-cutter/docs/intro-getting-started" target="_self">Introduction</a></li><li class="siteNavGroupActive"><a href="/cookie-cutter/docs/intro-inputs" target="_self">API</a></li><li class=""><a href="/cookie-cutter/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Modules</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-inputs">Inputs</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-message-handling">Message Handling</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-outputs">Outputs</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/versioning-contribution">Versioning and Contribution Guide</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Components</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-dispatch-context">Dispatch Context</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-state">State</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-metrics">Metrics</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-tracing">Tracing</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-validation">Validation</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-encoding">Encoding</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-config">Config</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-testing">Testing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Modules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-kafka">Kafka</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/cookie-cutter/docs/module-azure">Azure</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-amqp">AMQP</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-grpc">gRPC</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-validatejs">ValidateJS</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-mssql">MSSQL</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-timer">Timer</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-statsd">StatsD</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-protobuf">Protobuf</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-prometheus">Prometheus</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-redis">Redis</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-s3">S3</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Azure</h1></header><article><div><span><p>Cookie Cutter's Azure module is split into three major pieces:</p>
<ol>
<li><em>Event Sourced</em>: use this if your service is reading or manipulating state that is stored in the form of event streams</li>
<li><em>Materialized</em>: use this if your service's state follows a more traditional CRUD pattern</li>
<li><em>Streaming</em>: use this</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="event-sourced"></a><a href="#event-sourced" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Event Sourced</h2>
<h3><a class="anchor" aria-hidden="true" id="state-management"></a><a href="#state-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Management</h3>
<p>The <code>EventSourced</code> namespace in Cookie Cutter's Azure module is meant for dealing with state that is stored in the form of event streams. Below is an example where the event stream consists of two event types, Increment and Decrement, and the aggregated state is the sum of those events. When the service receives an input message, it will load the aggregate identified with the key <code>&quot;key-123&quot;</code> and try to append another Increment event to the same stream.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> Increment {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> readonly count: <span class="hljs-built_in">number</span></span>) { }
}

<span class="hljs-keyword">class</span> Decrement {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> readonly count: <span class="hljs-built_in">number</span></span>) { }
}

<span class="hljs-keyword">class</span> TallyState {
    <span class="hljs-keyword">public</span> total: <span class="hljs-built_in">number</span>;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">snapshot?: { total: <span class="hljs-built_in">number</span> }</span>) {
        <span class="hljs-keyword">this</span>.total = (snapshot &amp;&amp; snapshot.total) || <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">public</span> snap(): { total: <span class="hljs-built_in">number</span> } {
        <span class="hljs-keyword">return</span> { total: <span class="hljs-keyword">this</span>.total };
    }
}

<span class="hljs-keyword">class</span> TallyStateAggregator {
    <span class="hljs-keyword">public</span> onIncrement(msg: Increment, state: TallyState) {
        state.total += msg.count;
    }

    <span class="hljs-keyword">public</span> onDecrement(msg: Decrement, state: TallyState) {
        state.total -= msg.count;
    }
}

Application.create()
  .input()
      .add(<span class="hljs-keyword">new</span> StaticInputSource([
          { <span class="hljs-keyword">type</span>: <span class="hljs-string">"MyInput"</span>, payload: { amount: <span class="hljs-number">5</span> } },
      ]))
      .done()
  .state(EventSourced.cosmosState({
      url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
      key: <span class="hljs-string">"XXXXX"</span>,
      databaseId: <span class="hljs-string">"my-db"</span>,
      collectionId: <span class="hljs-string">"my-collection"</span>,
      encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
  }, TallyState, <span class="hljs-keyword">new</span> TallyStateAggregator()))
  .dispatch({
      onMyInput: (msg: IMyInput, ctx: IDispatchContext&lt;TallyState&gt;): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
          <span class="hljs-comment">// this will find all events (Increment and Decrement messages) in</span>
          <span class="hljs-comment">// the cosmos collection and aggregate them into TallyState using TallyStateAggregator</span>
          <span class="hljs-keyword">const</span> stateRef = <span class="hljs-keyword">await</span> ctx.state.get(<span class="hljs-string">"key-123"</span>);

          <span class="hljs-comment">// this will store an additional event into the event stream that</span>
          <span class="hljs-comment">// stateRef refers to ... it will also enforce optimistic concurrency, meaning</span>
          <span class="hljs-comment">// it will only append the new event if the event stream hasn't changed since</span>
          <span class="hljs-comment">// it was read last - otherwise it will retry by calling this event handler again</span>
          <span class="hljs-keyword">if</span> (stateRef.state.total &gt; <span class="hljs-number">0</span>) {
              ctx.store(Increment, stateRef, <span class="hljs-keyword">new</span> Increment(msg.amount));
          }
      }
  })
  .output()
      .stored(EventSourced.cosmosSink({
          url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
          key: <span class="hljs-string">"XXXXX"</span>,
          databaseId: <span class="hljs-string">"my-db"</span>,
          collectionId: <span class="hljs-string">"my-collection"</span>,
          encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
      }))
      .done()
  .run();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="snapshots"></a><a href="#snapshots" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Snapshots</h3>
<p>Sometimes event streams can get rather long and running the aggregation logic every time a stream is requested can add overhead and slow down the service. For that purpose the Azure module supports storing snapshots of an aggregate at a certain point in time (identified by a sequence number) in Azure Blob Storage. When a state is requested by a message handler the state provider will first load the latest snapshot of that state and then retrieve and apply all remaining events on top of that snapshot.</p>
<pre><code class="hljs css language-typescript">Application.create()
  .input()
      <span class="hljs-comment">// ...</span>
      .done()
  .state(EventSourced.cosmosState({
      url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
      key: <span class="hljs-string">"XXXXX"</span>,
      databaseId: <span class="hljs-string">"my-db"</span>,
      collectionId: <span class="hljs-string">"my-collection"</span>,
      encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
  }, TallyState, <span class="hljs-keyword">new</span> TallyStateAggregator(), blobStorageSnapshotProvider({
      storageAccount: <span class="hljs-string">"XXX"</span>,
      storageAccessKey: <span class="hljs-string">"YYYYY"</span>,
      container: <span class="hljs-string">"my-snapshots"</span>,
  })))
  .dispatch({
      <span class="hljs-comment">// ...</span>
  })
  .output()
      .stored(EventSourced.cosmosSink({
          url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
          key: <span class="hljs-string">"XXXXX"</span>,
          databaseId: <span class="hljs-string">"my-db"</span>,
          collectionId: <span class="hljs-string">"my-collection"</span>,
          encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
      }))
      .done()
  .run();
</code></pre>
<p>In order to write snapshots to Azure Blob Storage you'd usually setup a separate service that listens to the events from the underlying event sourced streams, aggregates them and then stores a snapshot of that aggregated state every N messages into Azure Blob Storage. The idiomatic way of doing this is to setup a change capture data feed from Cosmos into a message broker system like Kafka and then have a service listen to that message stream. Cookie Cutter has a helper function called <code>snapshotter</code> that can convert any event aggregator into a message handler that will emit a snapshot of the aggregated state automatically.</p>
<pre><code class="hljs css language-typescript">Application.create()
  .input()
      .add(kafkaSource({
          <span class="hljs-comment">// ...</span>
          topics: <span class="hljs-string">"cosmos-collection-changefeed"</span>,
      }))
      .done()
  .state(EventSourced.cosmosState({
      url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
      key: <span class="hljs-string">"XXXXX"</span>,
      databaseId: <span class="hljs-string">"my-db"</span>,
      collectionId: <span class="hljs-string">"my-collection"</span>,
      encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
  }, TallyState, <span class="hljs-keyword">new</span> TallyStateAggregator(), blobStorageSnapshotProvider({
      storageAccount: <span class="hljs-string">"XXX"</span>,
      storageAccessKey: <span class="hljs-string">"YYYYY"</span>,
      container: <span class="hljs-string">"my-snapshots"</span>,
  })))
  .dispatch(snapshotter(<span class="hljs-keyword">new</span> TallyStateAggregator()))
  .output()
      .stored(EventSourced.blobStorageSnapshotSink({
          storageAccount: <span class="hljs-string">"XXX"</span>,
          storageAccessKey: <span class="hljs-string">"YYYYY"</span>,
          container: <span class="hljs-string">"my-snapshots"</span>,
      }))
      .done()
  .run();
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="materialized"></a><a href="#materialized" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Materialized</h2>
<h3><a class="anchor" aria-hidden="true" id="state-management-1"></a><a href="#state-management-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Management</h3>
<p>Materialized Views work conceptually very similar to Event Sourced aggregates. The main difference is that there is no state aggregator class and the snapshot returned from the state class is used to persist the state in cosmos and rehydrate the state object from it.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> TallyState {
    <span class="hljs-keyword">public</span> total: <span class="hljs-built_in">number</span>;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">snapshot?: { total: <span class="hljs-built_in">number</span> }</span>) {
        <span class="hljs-keyword">this</span>.total = (snapshot &amp;&amp; snapshot.total) || <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">public</span> snap(): { total: <span class="hljs-built_in">number</span> } {
        <span class="hljs-keyword">return</span> { total: <span class="hljs-keyword">this</span>.total };
    }

    <span class="hljs-keyword">public</span> increment(amount: <span class="hljs-built_in">number</span>) {
        <span class="hljs-keyword">this</span>.total += amount;
    }
}

Application.create()
  .input()
      .add(<span class="hljs-keyword">new</span> StaticInputSource([
          { <span class="hljs-keyword">type</span>: <span class="hljs-string">"MyInput"</span>, payload: { amount: <span class="hljs-number">5</span> } },
      ]))
      .done()
  .state(Materialized.cosmosState({
      url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
      key: <span class="hljs-string">"XXXXX"</span>,
      databaseId: <span class="hljs-string">"my-db"</span>,
      collectionId: <span class="hljs-string">"my-collection"</span>,
      encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
  }, TallyState))
  .dispatch({
      onMyInput: (msg: IMyInput, ctx: IDispatchContext&lt;TallyState&gt;): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
          <span class="hljs-comment">// this will retrieve the document in cosmos with the specified key and then use the</span>
          <span class="hljs-comment">// content of that document as the snapshot parameter of the TallyState constructor</span>
          <span class="hljs-keyword">const</span> stateRef = <span class="hljs-keyword">await</span> ctx.state.get(<span class="hljs-string">"key-123"</span>);

          <span class="hljs-comment">// this will store the snapshot of the updated state back to cosmos ... it will </span>
          <span class="hljs-comment">// also enforce optimistic concurrency, meaning it will only overwrite the current</span>
          <span class="hljs-comment">// state if it hasn't changed since it was read last - otherwise it will retry </span>
          <span class="hljs-comment">// by calling this event handler again</span>
          <span class="hljs-keyword">if</span> (stateRef.state.total &gt; <span class="hljs-number">0</span>) {
              stateRef.state.increment(msg.amount);
              ctx.store(Increment, stateRef, stateRef.state.snap());
          }
      }
  })
  .output()
      .stored(Materialized.cosmosSink({
          url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
          key: <span class="hljs-string">"XXXXX"</span>,
          databaseId: <span class="hljs-string">"my-db"</span>,
          collectionId: <span class="hljs-string">"my-collection"</span>,
          encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
      }))
      .done()
  .run();
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="streaming"></a><a href="#streaming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Streaming</h2>
<p>All sinks in the Streaming namespace will react to <code>publish</code><em>ed</em> messages vs. <code>store</code><em>d</em> messages as they are expected for Event Sourced and Materialized Views. This means that there is no optimistic concurrency for anything under Streaming.</p>
<h3><a class="anchor" aria-hidden="true" id="cosmos"></a><a href="#cosmos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cosmos</h3>
<p>The purpose of this sink is to append messages to Cosmos without any additional checks. It will still ensure monotonically increasing sequence numbers per event stream, but it will not retry the entire message handler on sequence number conflicts. Instead it will just insert the document with the next available sequence number. The setup for this is similar to the Event Sourced output sink as described above.</p>
<pre><code class="hljs css language-typescript">Application.create()
  <span class="hljs-comment">// ...</span>
  .dispatch({
      onMyInput: (msg: IMyInput, ctx: IDispatchContext) {
          ctx.publish(Increment, <span class="hljs-keyword">new</span> Increment(msg.amount));
      }
  })
  .output()
      .published(Streaming.cosmosSink({
          url: <span class="hljs-string">"https://my-db.cosmos.azure.com"</span>,
          key: <span class="hljs-string">"XXXXX"</span>,
          databaseId: <span class="hljs-string">"my-db"</span>,
          collectionId: <span class="hljs-string">"my-collection"</span>,
          encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
      }))
      .done()
  .run();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="queues"></a><a href="#queues" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Queues</h3>
<p>Azure Queues is a FIFO queue implementation that is backed by an Azure SLA.</p>
<h4><a class="anchor" aria-hidden="true" id="enqueuing-items"></a><a href="#enqueuing-items" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enqueuing Items</h4>
<pre><code class="hljs css language-typescript">Application.create()
    .input()
        .add(intervalSource({
            timeoutMs: <span class="hljs-number">100</span>,
        }))
        .done()
    .dispatch({
        onInterval: <span class="hljs-function">(<span class="hljs-params">_: IInterval, ctx: IDispatchContext</span>) =&gt;</span> {
            ctx.publish&lt;ISomeTask&gt;(SomeTask, {
                taskId: <span class="hljs-string">"1234"</span>,
                task: <span class="hljs-string">"do something"</span>,
            });
        },
    })
    .output()
        .published(Streaming.queueSink({
            storageAccount: <span class="hljs-string">"[SOME_ACCOUNT]"</span>,
            storageAccessKey: <span class="hljs-string">"[SOME_KEY]"</span>,
            queueName: <span class="hljs-string">"[QUEUE_NAME]"</span>,
            encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
        }))
        .done()
    .run();
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="consuming-items"></a><a href="#consuming-items" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consuming Items</h4>
<pre><code class="hljs css language-typescript">Application.create()
    .input()
        .add(Streaming.queueSource({
          storageAccount: <span class="hljs-string">"[SOME_ACCOUNT]"</span>,
          storageAccessKey: <span class="hljs-string">"[SOME_KEY]"</span>,
          queueName: <span class="hljs-string">"[QUEUE_NAME]"</span>,
          encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
          visibilityTimeout: <span class="hljs-number">30</span>, <span class="hljs-comment">// seconds, Azure default: 30 seconds</span>
          numOfMessages: <span class="hljs-number">32</span>, <span class="hljs-comment">// Azure default: 1</span>
        }))
        .done()
    .dispatch({
        onSomeTask: <span class="hljs-function">(<span class="hljs-params">_msg: ISomeTask, ctx: IDispatchContext</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> dequeueCount = ctx.metadata(QueueMetadata.DequeueCount);
            <span class="hljs-keyword">if</span> (dequeueCount &gt; <span class="hljs-number">10</span>) {
                <span class="hljs-comment">// maybe time to give up if it hasn't worked the last 10 times ...</span>
            }
        },
    })
    .run(ErrorHandlingMode.LogAndContinue, ParallelismMode.Serial);
</code></pre>
<p>It is recommended to run the service in Serial mode with <code>queueSource</code> because once the message is received from Azure Queues its visibility timeout window starts and running the service in serial mode will decrease the chance of hitting the window timeout as messages are queued up internally in Cookie Cutter in Concurrent mode.</p>
<p>Queues items will be reprocessed if you throw an error in the message handler function. The <code>DequeueCount</code> metadata can be used to detect reprocessed messages and skip over those if appropriate.</p>
<h3><a class="anchor" aria-hidden="true" id="dead-letter-queue"></a><a href="#dead-letter-queue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dead Letter Queue</h3>
<p>It is possible to designate a queue to serve as a dead letter queue. <code>maxDequeueCount</code> specifies how many times a message can be dequeued before it is sent to the dead letter queue. The visibility timeout and message time to live will default to the values of the main queue unless the values are explicitly overwritten.</p>
<pre><code class="hljs css language-typescript">Application.create()
    .input()
        .add(Streaming.queueSource({
          storageAccount: <span class="hljs-string">"[SOME_ACCOUNT]"</span>,
          storageAccessKey: <span class="hljs-string">"[SOME_KEY]"</span>,
          queueName: <span class="hljs-string">"[QUEUE_NAME]"</span>,
          encoder: <span class="hljs-keyword">new</span> JsonMessageEncoder(),
          deadLetterQueue: {
              queueName: <span class="hljs-string">"[OTHER_QUEUE_NAME]"</span>,
              maxDequeueCount: <span class="hljs-number">10</span>,
              visibilityTimeout: <span class="hljs-number">30</span>, <span class="hljs-comment">// seconds, Azure default: 30 seconds</span>
              messageTimeToLive: <span class="hljs-number">120</span>, <span class="hljs-comment">// seconds, Azure default: 7 days</span>
          }
        }))
        .done()
    .dispatch({
        onSomeTask: <span class="hljs-function">(<span class="hljs-params">_msg: ISomeTask, _ctx: IDispatchContext</span>) =&gt;</span> {
            <span class="hljs-comment">// ...</span>
        },
    })
    .run(ErrorHandlingMode.LogAndContinue, ParallelismMode.Serial);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="metadata"></a><a href="#metadata" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Metadata</h3>
<p>The following metadata is available</p>
<table>
<thead>
<tr><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>GrpcMetadata.Peer</td><td>the host and port of the client sending the request</td></tr>
<tr><td>QueueMetadata.QueueName</td><td>Queue name</td></tr>
<tr><td>QueueMetadata.VisibilityTimeout</td><td>When passed into msg metadata via <code>publish</code>/<code>store</code>: Specifies the new visibility timeout value, in seconds, relative to server time</td></tr>
<tr><td>QueueMetadata.VisibilityTimeoutMs</td><td>When passed into msg metadata via <code>publish</code>/<code>store</code>: Specifies the new visibility timeout value, in milliseconds, relative to server time</td></tr>
<tr><td>QueueMetadata.VisibilityTimeout</td><td>When read from the MessageRef metadata: Returns the date when the message will next be visible in string format: &quot;Tue, 21 Apr 2020 16:33:23 GMT&quot;</td></tr>
<tr><td>QueueMetadata.TimeToLive</td><td>When passed into msg metadata via <code>publish</code>/<code>store</code>: The time-to-live interval for the message, in seconds.</td></tr>
<tr><td>QueueMetadata.TimeToLiveMs</td><td>When passed into msg metadata via <code>publish</code>/<code>store</code>: The time-to-live interval for the message, in milliseconds.</td></tr>
<tr><td>QueueMetadata.TimeToLive</td><td>When read from the MessageRef metadata: Returns the date when the message will expire in string format: &quot;Tue, 21 Apr 2020 16:33:23 GMT&quot;</td></tr>
<tr><td>QueueMetadata.DequeueCount</td><td>Number of times a message has been dequeued</td></tr>
<tr><td>QueueMetadata.TimeToNextVisible</td><td>not used</td></tr>
<tr><td>QueueMetadata.MessageId</td><td>The message identifier of the message</td></tr>
<tr><td>QueueMetadata.PopReceipt</td><td>A valid pop receipt value returned from an earlier call to the Get Messages or Update Message operation</td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/cookie-cutter/docs/module-kafka"><span class="arrow-prev">← </span><span>Kafka</span></a><a class="docs-next button" href="/cookie-cutter/docs/module-amqp"><span>AMQP</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#event-sourced">Event Sourced</a><ul class="toc-headings"><li><a href="#state-management">State Management</a></li><li><a href="#snapshots">Snapshots</a></li></ul></li><li><a href="#materialized">Materialized</a><ul class="toc-headings"><li><a href="#state-management-1">State Management</a></li></ul></li><li><a href="#streaming">Streaming</a><ul class="toc-headings"><li><a href="#cosmos">Cosmos</a></li><li><a href="#queues">Queues</a></li><li><a href="#dead-letter-queue">Dead Letter Queue</a></li><li><a href="#metadata">Metadata</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/cookie-cutter/" class="nav-home"><img src="/cookie-cutter/img/cookie.svg" alt="Cookie Cutter" width="66" height="58"/></a><div><h5>Docs</h5><a href="/cookie-cutter/docs/intro-getting-started.html">Introduction</a><a href="/cookie-cutter/docs/module-kafka.html">Kafka</a></div><div><h5>More</h5><a href="/cookie-cutter/blog">Blog</a></div></section><section class="copyright">Copyright © 2022 Walmart Inc.</section></footer></div></body></html>