<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>State · Cookie Cutter</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Reading State"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="State · Cookie Cutter"/><meta property="og:type" content="website"/><meta property="og:url" content="https://walmartlabs.github.io/cookie-cutter/"/><meta property="og:description" content="## Reading State"/><meta property="og:image" content="https://walmartlabs.github.io/cookie-cutter/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://walmartlabs.github.io/cookie-cutter/img/docusaurus.png"/><link rel="shortcut icon" href="/cookie-cutter/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/cookie-cutter/js/scrollSpy.js"></script><link rel="stylesheet" href="/cookie-cutter/css/main.css"/><script src="/cookie-cutter/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/cookie-cutter/"><img class="logo" src="/cookie-cutter/img/cookie.svg" alt="Cookie Cutter"/><h2 class="headerTitleWithLogo">Cookie Cutter</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/cookie-cutter/docs/intro-getting-started" target="_self">Introduction</a></li><li class="siteNavGroupActive"><a href="/cookie-cutter/docs/intro-inputs" target="_self">API</a></li><li class=""><a href="/cookie-cutter/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Components</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-inputs">Inputs</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-message-handling">Message Handling</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/intro-outputs">Outputs</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/versioning-contribution">Versioning and Contribution Guide</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Components</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-dispatch-context">Dispatch Context</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/cookie-cutter/docs/comp-state">State</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-metrics">Metrics</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-tracing">Tracing</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-validation">Validation</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-encoding">Encoding</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-config">Config</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/comp-testing">Testing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Modules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-kafka">Kafka</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-azure">Azure</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-amqp">AMQP</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-grpc">gRPC</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-validatejs">ValidateJS</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-mssql">MSSQL</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-timer">Timer</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-statsd">StatsD</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-protobuf">Protobuf</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-prometheus">Prometheus</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-redis">Redis</a></li><li class="navListItem"><a class="navItem" href="/cookie-cutter/docs/module-s3">S3</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">State</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="reading-state"></a><a href="#reading-state" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading State</h2>
<p>A service can access state from any message handler function via the dispatch context's <code>state</code> property. The <code>get</code> method reads in the state for a specified key from the underlying storage system. Whether the state is an aggregate of an underlying event stream or a direct representation of a row in a database is transparent to the message handler at this point, it will always receive an instance of the domain model representation of the state.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMyInput</span>(<span class="hljs-params">msg: IMyInput, ctx: IDispatchContext&lt;MyState&gt;</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">void</span>&gt; </span>{
    <span class="hljs-keyword">const</span> stateRef = <span class="hljs-keyword">await</span> ctx.state.get(<span class="hljs-string">"customer-18483"</span>);
    ctx.logger.info(<span class="hljs-string">"loaded state"</span>, {
        key: stateRef.key,
        seqNum: stateRef.seqNum,
        isNew: stateRef.isNew,
        state: <span class="hljs-built_in">JSON</span>.stringify(stateRef.state),
    });
}
</code></pre>
<p>However, the <code>get</code> method does not only return the state object itself, but wraps it in a <code>StateRef</code> which contains the state's identity (key + sequence number) as well. A <code>StateRef</code> is used as a token for optimistic concurrency, the sink will use it to make sure it only persists new state if the old one hasn't changed in the mean time.</p>
<h2><a class="anchor" aria-hidden="true" id="state-domain-model"></a><a href="#state-domain-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Domain Model</h2>
<p>You are free to design the domain model of the state in any shape or form that suites your service. There is only one convention the state needs to adhere to: it must have a constructor that accepts a snapshot and it must have a method called <code>snap</code> that returns a snapshot. The idea is that these two operations can be combined to fulfill <code>expect(new MyState(state.snap())).toMatchObject(state)</code>, meaning the framework can use a combination of the <code>snap</code> function and the constructor to create a deep copy of the state. This also means that <code>snap</code> should return a snapshot that in fact is a deep copy and not a shallow copy of state internals. It is also a good practice to only use data types for the snapshot that can be serialized nicely as the snapshot may get serialized and persisted if for instance snapshotting is enabled for event sourced states.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">interface</span> IMyStateSnapshot {
    readonly name: <span class="hljs-built_in">string</span>;
    readonly tags: <span class="hljs-built_in">string</span>[];
}

<span class="hljs-keyword">class</span> MyState {
    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">private</span> tags: Set&lt;<span class="hljs-built_in">string</span>&gt;;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">snapshot?: IMyStateSnapshot</span>) {
        <span class="hljs-keyword">if</span> (snapshot) {
            <span class="hljs-keyword">this</span>.name = snapshot.name;
            <span class="hljs-keyword">this</span>.tags = <span class="hljs-keyword">new</span> Set(snapshot.tags);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"default"</span>;
            <span class="hljs-keyword">this</span>.tags = <span class="hljs-keyword">new</span> Set();
        }
    }

    <span class="hljs-keyword">public</span> snap(): IMyStateSnapshot {
        <span class="hljs-keyword">return</span> {
            name: <span class="hljs-keyword">this</span>.name,
            tags: <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>.tags.values),
        };
    }

    <span class="hljs-keyword">public</span> hasTag(tag: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tags.has(tag);
    }

    <span class="hljs-keyword">public</span> addTag(tag: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">this</span>.tags.add(tag);
    }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="state-aggregation-event-sourcing"></a><a href="#state-aggregation-event-sourcing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Aggregation (Event Sourcing)</h2>
<p>If the state is event sourced you will need to implement an aggregator in addition to the state domain model. The aggregator is responsible for applying the individual events from the state's event stream to the aggregated domain model. Assuming the event stream consists of <code>NameChanged</code> and <code>TagsAdded</code> events then an aggregator class for <code>MyState</code> could look like this.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> MyStateAggregator {
    <span class="hljs-keyword">public</span> onNameChanged(msg: INameChanged, state: MyState): <span class="hljs-built_in">void</span> {
        state.name = msg.name;
    }

    <span class="hljs-keyword">public</span> onTagsAdded(msg: ITagsAdded, state: MyState): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> tag of msg.tags) {
            state.addTag(tag);
        }
    }
}
</code></pre>
<p>State Aggregators are structurally very similar to message handlers. They follow the same naming convention for function names and receive the event to process as the first argument. The second argument is the state the event should be applied to - this will be same instance throughout the aggregation process. The aggregator class itself should be stateless as it will be reused for all states it aggregates.</p>
<p>Also one important distinction between message handlers and state aggregators: aggregators <em>must not</em> be asynchronous.</p>
<h2><a class="anchor" aria-hidden="true" id="state-providers"></a><a href="#state-providers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Providers</h2>
<p>State providers are what powers the <code>ctx.state.get</code> function available in message handlers. Their responsibility is to read the state's raw data from an underlying storage system and transform it into the state domain model the service uses. State providers are not responsible for storing state, however.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IStateProvider&lt;TState&gt; {
    <span class="hljs-keyword">get</span>(spanContext: SpanContext, key: <span class="hljs-built_in">string</span>, atSn?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">Promise</span>&lt;StateRef&lt;TState&gt;&gt;;
    compute(stateRef: StateRef&lt;TState&gt;, events: IMessage[]): StateRef&lt;TState&gt;;
}
</code></pre>
<p>Each state provider implements a <code>get</code> and a <code>compute</code> operation. <code>get</code> matches the <code>ctx.state.get</code> function from the message handler (the <code>SpanContext</code> in the interface's function is supplied automatically by the framework). The <code>atSn</code> argument is optional and may or may not be supported depending on the state provider. Event sourced state providers should generally support retrieving the state as of a specified sequence number whereas state providers for materialized views might not be able to load state at a certain point in time and will always return the latest state.</p>
<p><code>compute</code> is used to derive a new state in-memory based on an existing state and additional events that should be applied on top of that. For an event sourced state provider the behavior is rather obvious (it applies the <code>events</code> on top of <code>stateRef</code> using the state aggregator class). Materialized views work by calling <code>ctx.store</code> with the new version of the state's snapshot, so in that case <code>compute</code> would just take the last item from <code>events</code> and return it as a new <code>StateRef</code>.</p>
<p>From the message handler you can use <code>compute</code> with a simplified API</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDispatchState&lt;TState&gt; {
    <span class="hljs-keyword">get</span>(key: <span class="hljs-built_in">string</span>, atSn?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">Promise</span>&lt;StateRef&lt;TState&gt;&gt;;
    compute(): <span class="hljs-built_in">Array</span>&lt;StateRef&lt;TState&gt;&gt;;
    compute(key: <span class="hljs-built_in">string</span>): StateRef&lt;TState&gt; | <span class="hljs-literal">undefined</span>;
}
</code></pre>
<p><code>compute</code> without any arguments will return a list of all states that are changed via <code>ctx.store</code> calls and <code>compute(key)</code> will return just one state for the specified key (or <code>undefined</code> if the state hasn't been changed).</p>
<h2><a class="anchor" aria-hidden="true" id="updating-state"></a><a href="#updating-state" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Updating State</h2>
<p>State is updated in the underlying persistence layer via an output sink. Usually you will configure a matching pair of state provider and output sink.</p>
<pre><code class="hljs css language-typescript">Application.create()
    .state(myEventSourcedStateProvider)
    .dispatch({
        onInput: <span class="hljs-keyword">async</span> (msg: IInput, ctx: IDispatchContext&lt;MyState&gt;): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
            <span class="hljs-keyword">const</span> stateRef = ctx.state.get(msg.id);
            ctx.store(NewEvent, stateRef, { <span class="hljs-comment">/* some payload */</span> });
        }
    })
    .output()
        .stored(myEventSourcedStateSink)
        .done()
    .run();
</code></pre>
<p>The output sink will receive all messages that were <code>store</code><em>d</em> by message handler and try to write them to the underlying persistence mechanism with optimistic concurrency (<code>stateRef</code> serves as the optimistic concurrency token in this case). In case of a failure due to optimistic concurrency the message handler will be invoked again until it finally succeeds.</p>
<h2><a class="anchor" aria-hidden="true" id="state-cache"></a><a href="#state-cache" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Cache</h2>
<p>For a lot of applications it makes sense to cache state in-memory to avoid incurring the cost of read I/O for every single state transition. Cookie Cutter provides a generic state caching mechanism that works with any state provider. It can be enabled like this</p>
<pre><code class="hljs css language-typescript">Application.create()
    .state(cached(
        MyState,
        myEventSourcedStateProvider(
            MyState,
            <span class="hljs-keyword">new</span> MyStateAggregator(),
        )
    ))
</code></pre>
<p>It's a decorator function around the underlying state provider. By default it will keep a LRU cache of the last 1,000 states by key. The states in the cache will automatically be updated after each message handler execution using the <code>compute</code> function described above. This means that even if the state changes over time it can still be served from the cache and we only have to perform I/O to retrieve the initial state that the service then can build upon.</p>
<p>The invalidation strategy for this cache is optimistic concurrency. The framework will consider the cached state up-to-date until it encounters an optimistic concurrency failure at which point it invalidates that cache entry and fetches the latest state from the underlying state provider during the retry loop.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/cookie-cutter/docs/comp-dispatch-context"><span class="arrow-prev">← </span><span>Dispatch Context</span></a><a class="docs-next button" href="/cookie-cutter/docs/comp-metrics"><span>Metrics</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#reading-state">Reading State</a></li><li><a href="#state-domain-model">State Domain Model</a></li><li><a href="#state-aggregation-event-sourcing">State Aggregation (Event Sourcing)</a></li><li><a href="#state-providers">State Providers</a></li><li><a href="#updating-state">Updating State</a></li><li><a href="#state-cache">State Cache</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/cookie-cutter/" class="nav-home"><img src="/cookie-cutter/img/cookie.svg" alt="Cookie Cutter" width="66" height="58"/></a><div><h5>Docs</h5><a href="/cookie-cutter/docs/intro-getting-started.html">Introduction</a><a href="/cookie-cutter/docs/module-kafka.html">Kafka</a></div><div><h5>More</h5><a href="/cookie-cutter/blog">Blog</a></div></section><section class="copyright">Copyright © 2020 Walmart Inc.</section></footer></div></body></html>